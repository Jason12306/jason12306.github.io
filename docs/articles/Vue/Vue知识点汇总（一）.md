### 一、计算属性缓存 vs 方法
计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。

### 二、计算属性的 setter
计算属性默认只有 getter，不过在需要时你也可以提供一个 setter。

### 三、关于`v-for`中`key`
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key`

### 四、插槽
4.1 编译作用域
父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。

4.2 作用域插槽
有时需要让插槽内容能够访问子组件中数据。可以将 数据 作为 `<slot>` 元素的一个 `attribute` 绑定上去。在父级作用域中，可以使用带值的 `v-slot` 来定义我们提供的插槽 `prop` 的名字。
```
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
```
```
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user
```

`slot attribute`已废弃，采用新的 `v-slot`指令。

























