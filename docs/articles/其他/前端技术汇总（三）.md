### 一、防抖和节流
防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

### 二、ES5/ES6 的继承除了写法以外还有什么区别
1. class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
2. class 声明内部会启用严格模式。
3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4. class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
5. 必须使用 new 调用 class。
6. class 内部无法重写类名。

### 三、TCP三次握手和四次挥手

> TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

#### 三次握手
“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

`第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

`第二次握手`：服务端发包，客户端收到了。客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。

`第三次握手`：客户端发包，服务端收到了。服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

#### 四次挥手
TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。

1. 当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。
2. 这时对方会回一个ACK，此时一个方向的连接关闭。
3. 但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。
4. 接收方发送ACK确认关闭连接。

ACK —— 确认(Acknowledge Character)，确认字符。 
RST —— 重置连接（reset by peer）。 
SYN —— 用于初如化一个连接的序列号（Synchronize）。
FIN —— 该报文段的发送方已经结束向对方发送数据（Final）。
[参考资料](https://zhuanlan.zhihu.com/p/53374516)

### 四、浏览器重绘与回流（Repaint & Reflow）

1. 浏览器渲染机制
- 浏览器采用流式布局模型（Flow Based Layout）
- 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）
- 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
- 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。

2. 回流
通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。

3. 重绘
通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

**回流一定会触发重绘，而重绘不一定会回流**

4. 何时发生回流重绘？
当页面布局和几何信息发生变化的时候，就需要回流。比如：
- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

5. 优化
5.1 批量修改DOM
  1. 使元素脱离文档流
  2. 对其进行多次修改
  3. 将元素带回到文档中

5.2 合并多次对DOM和样式的修改，一次处理掉（大部分现代浏览器已做优化）
5.3 隐藏元素，应用修改，重新显示
5.4 对于复杂动画效果,使用绝对定位让其脱离文档流


不可见的节点包括：
- 一些不会渲染输出的节点，比如script、meta、link等。
- 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

[参考资料](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)