### 一、JS中基本数据类型
`String`,`Number`,`Boolean`,`null`,`undefined`,`Object`, [Symbol](https://es6.ruanyifeng.com/#docs/symbol)

>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突

### 二、**this**关键字
`this` 总是指向一个对象，具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

### 三、 `Function.prototype.call` 和 `Function.prototype.apply`
`call`和`apply`都可以动态地改变传入函数的 `this`，作用一模一样。区别仅在于传入参数的形式不同。
`apply`第一个参数指定函数体内`this`指向，第二个参数为一个带下标的集合，可为数组或类数组；`call`第一个参数同上，从第二个参数往后，每个参数被依次传入函数;`call`是包装在`apply`上面的一个语法糖，使用`call`或`apply`的时候，若第一个参数为`null`，函数体的`this`指向默认宿主对象
`bind`与`call`相同，区别是是其返回的是函数，需要手动执行。

### 四、闭包
闭包的形成与变量的作用域以及变量的生存周期密切相关。变量的生命周期，全局变量的生存周期是永久的，除非主动销毁，对于在函数内用`var`声明的变量来说，当退出函数时，变量即失去了它们的价值，随着函数调用的结束而被销毁。

### 五、高阶函数
高阶函数是指满足下列条件之一的函数：
1. 函数可以作为参数被传递；
2. 函数可以作为返回值输出（让函数继续返回一个可执行的函数，意味着运算过程是可延续的。）。

1.1 回调函数 `callback`
1.2 ` Array.prototype.sort`方法

### 六、函数柯里化（currying）
`currying`又称部分求值。一个`currying`的函数首先会接收一些参数，接收这些参数之后，函数不会立即求值，而是继续返回另一个函数，刚传入的参数在函数形成的闭包中被保存。待函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

### 七、函数性能优化

7.1 函数节流
实现：将即将被执行的函数用 `setTimeout` 延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。

7.2 分时函数
客观原因需要加载海量数据，可以让工作分批进行，比如每秒执行1000次运算，利用 `setInterval` 进行分批执行，即使用时间作为杠杆，换取性能。

7.3 惰性加载函数
第一次进入条件分支后，**在函数内部重写该函数**，重写后的函数就是我们期待的函数。

7.4 函数防抖
一段时间内没有再触发事件，才会触发一次。例如：页面滚动间隔一段时间后再触发某一事件
```js
function debounce(fn, wait) {
    var timeout = null;
    return function () {
      if (timeout !== null) clearTimeout(timeout);
      timeout = setTimeout(fn, wait);
    }
  }
  // 处理函数
  function handle() {
    console.log(Math.random());
  }
  // 滚动事件
  window.addEventListener(scroll, debounce(handle, 1000));
```

### 八、设计模式

**设计模式的主题总是把不变的事物和变化的事物分离开。**

8.1 单例模式
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

8.2 策略模式
定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互转换。

8.3 发布-订阅模式（观察者模式）
优势：1. 时间上解耦；2. 对象间解耦。无论是**MVC**还是**MVVM**中都有发布-订阅模式的参与，而且`JavaScript`也是基于事件驱动的语言。
缺点：创建订阅者本身需要消耗一定的时间和内存，弱化的对象之间的联系。过度使用会导致程序难以跟踪和理解。

8.4 享元模式
享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是**运用共享技术来有效支持大量细粒度的对象**。关键是如何区别内部状态和外部状态。


其他：代理模式、迭代器模式、命令模式（创建一系列命令类似于策略模式）、组合模式、模板方法模式

### 九、深拷贝
9.1  `JSON`反序列化实现 `JSON.parse(JSON.stringify(Obj))`
缺点：
不支持函数
不支持undefined（支持null）
不支持循环引用
不支持`Date`，会变成 `ISO8601` 格式的字符串
不支持正则表达式
不支持`Symbol`

9.2 递归拷贝

### 十、CSS选择符
（1）id选择器（#myid）
（2）类选择器（.myclassname）
（3）标签选择器（div,h1,p）
（4）后代选择器（h1p）
（5）相邻后代选择器（子）选择器（ul>li）
（6）兄弟选择器（li~a）
（7）相邻兄弟选择器（li+a）
（8）属性选择器（a[rel="external"]）
（9）伪类选择器（a:hover,li:nth-child）
（10）伪元素选择器（::before、::after）
（11）通配符选择器（*）

### 十一、::before 和:after 中双冒号和单冒号有什么区别
单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）。

**伪类与伪元素的区别**

**伪类**用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。

**伪元素**用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过`::before`来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

### 十二、CSS 中哪些属性可以继承
（1）字体系列属性
（2）文本系列属性
（3）表格布局属性
（4）列表属性
（5）光标属性
（6）元素可见性

### 十三、关于伪类 LVHA
`a`标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类 `:link`、`:visited`、`:hover`、`:active`；

### 十四、关于 BFC(BlockFormattingContext)块级格式化上下文
BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。

### 十五、`new`操作符与`Object.create()`
相同点：都是创建一个对象
不同点： 
  `new`关键字会进行如下操作：
  1. 创建一个空的简单js对象（即`{}`）；
  2. 链接该对象（设置该对象的`constructor`）到另一个对象；
  3. 将步骤1新创建的对象作为this的上下文 ；
  4. 如果该函数没有返回对象，则返回`this`。
```js
function create(Con, ...args){
  // 创建一个空的对象
  this.obj = {};
  // 将空对象指向构造函数的原型链
  Object.setPrototypeOf(this.obj, Con.prototype);
  // obj绑定到构造函数上，便可以访问构造函数中的属性，即this.obj.Con(args)
  let result = Con.apply(this.obj, args);
  // 如果返回的result是一个对象则返回
  // new方法失效，否则返回obj
  return result instanceof Object ? result : this.obj;
}
```

`Object.create()`使用现有的对象来提供新创建的对象的__proto__。
1. 创建一个函数；
2. 将该函数的原型指向传入的实例对象；
3. 返回该函数的一个实例。

```js
function create =  function (o) {
    var F = function () {};
    F.prototype = o;
    return new F();
};
```

### 十六、`Object.setPrototypeOf(obj, prototype)`
设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null;原型会同步过来，属性则不会。

### 十七、从输入URL到页面加载发生了什么？
大概分为以下步骤：
URL输入
DNS解析
TCP连接
发送HTTP请求
服务器处理请求
服务器响应请求
浏览器解析渲染页面
连接结束
[参考资料](https://juejin.im/post/6844903616101220366)

### 十八、浏览器渲染HTML过程
浏览器是一个边解析边渲染的过程，浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。JS的解析是由浏览器中的JS解析引擎完成的，JS是单线程运行。