import{_ as i,c as a,o as n,a2 as t}from"./chunks/framework.CnKoBJ9A.js";const y=JSON.parse('{"title":"TypeScript 动态参数返回类型实现","description":"","frontmatter":{},"headers":[],"relativePath":"articles/TypeScript/TypeScript动态参数返回类型实现.md","filePath":"articles/TypeScript/TypeScript动态参数返回类型实现.md"}'),p={name:"articles/TypeScript/TypeScript动态参数返回类型实现.md"};function l(h,s,e,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="typescript-动态参数返回类型实现" tabindex="-1">TypeScript 动态参数返回类型实现 <a class="header-anchor" href="#typescript-动态参数返回类型实现" aria-label="Permalink to &quot;TypeScript 动态参数返回类型实现&quot;">​</a></h1><p>为了实现动态根据参数生成返回类型，需要使用 TypeScript 的 const 泛型参数和映射类型。以下是解决方案：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> zzz</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PropertyKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }[]&gt;(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">acc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    acc[item.name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, {} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> answers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> zzz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([{ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// answers 类型为 { aa: string; bb: string }</span></span></code></pre></div><p><strong>关键点解析：</strong></p><ol><li><p><strong>const 泛型参数 (<code>&lt;const T&gt;</code>)</strong></p><ul><li>使 TypeScript 将传入的数组推断为字面量类型</li><li>保留数组元素中 <code>name</code> 属性的具体字面量类型（如 &#39;aa&#39; 而不是 string）</li></ul></li><li><p><strong>类型约束 (<code>readonly { name: PropertyKey }[]</code>)</strong></p><ul><li>确保传入的是只读数组（保持类型推断稳定性）</li><li><code>PropertyKey</code> 保证 name 属性可作为对象键（string | number | symbol）</li></ul></li><li><p><strong>映射类型 (<code>{ [K in T[number][&quot;name&quot;]]: string }</code>)</strong></p><ul><li><code>T[number]</code> 获取数组元素类型的联合</li><li><code>T[number][&quot;name&quot;]</code> 提取所有元素的 name 属性值的联合类型</li><li>用这些字面量值作为新对象的键，值类型为 string</li></ul></li></ol><p><strong>注意事项：</strong></p><ul><li>需要 TypeScript 4.9+ 支持 const 泛型参数</li><li>实际实现需要使用类型断言（<code>as any</code>），因为 TypeScript 无法在 reduce 过程中验证动态键</li><li>重复的 name 会导致后续值覆盖前面的，但类型系统不会报错（需业务逻辑自行处理）</li></ul><p>最终效果：当传入 <code>[{ name: &#39;aa&#39; }, { name: &#39;bb&#39; }]</code> 时，自动推导返回类型为 <code>{ aa: string; bb: string }</code>。</p>`,8)]))}const g=i(p,[["render",l]]);export{y as __pageData,g as default};
