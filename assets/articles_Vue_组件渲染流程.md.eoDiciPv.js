import{_ as a,c as t,o as r,a2 as o}from"./chunks/framework.CnKoBJ9A.js";const n="/assets/render-pipeline.Ir827OG1.png",m=JSON.parse('{"title":"组件渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Vue/组件渲染流程.md","filePath":"articles/Vue/组件渲染流程.md"}'),l={name:"articles/Vue/组件渲染流程.md"};function i(d,e,c,p,s,h){return r(),t("div",null,e[0]||(e[0]=[o('<h1 id="组件渲染流程" tabindex="-1">组件渲染流程 <a class="header-anchor" href="#组件渲染流程" aria-label="Permalink to &quot;组件渲染流程&quot;">​</a></h1><p>大致流程： 编译 <code>&lt;template&gt;&lt;/template&gt;</code>模板，生成<code>render</code>函数，执行 render 函数（响应式数据会将其作为依赖收集）生成 vnode，通过 patch 过程（diff）得到要渲染到视图中的 vnode，通过 vnode 创建真实 dom 并挂载到节点中。</p><p>当组件响应式数据更新时，render 函数由于之前被作为响应式数据副作用函数收集，所以会重新执行</p><h2 id="渲染管线" tabindex="-1">渲染管线 <a class="header-anchor" href="#渲染管线" aria-label="Permalink to &quot;渲染管线&quot;">​</a></h2><p><img src="'+n+'" alt="渲染管线"></p><ol><li>编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li><li>挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。</li><li>更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li></ol><p><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#render-pipeline" target="_blank" rel="noreferrer">官方文档</a></p><h2 id="挂载与更新-patch" tabindex="-1">挂载与更新（patch） <a class="header-anchor" href="#挂载与更新-patch" aria-label="Permalink to &quot;挂载与更新（patch）&quot;">​</a></h2><p>/packages/runtime-core/src/renderer/patch:367</p><h2 id="vnode-的优势-pg36" tabindex="-1">vnode 的优势（pg36） <a class="header-anchor" href="#vnode-的优势-pg36" aria-label="Permalink to &quot;vnode 的优势（pg36）&quot;">​</a></h2><ul><li>抽象，渲染过程抽象化，组件抽象能力得到提升</li><li>跨平台，对于 patch vnode 过程各平台可以有自己的实现</li></ul>',11)]))}const u=a(l,[["render",i]]);export{m as __pageData,u as default};
