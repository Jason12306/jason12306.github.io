import{_ as i,c as a,o as e,a2 as n}from"./chunks/framework.CnKoBJ9A.js";const o=JSON.parse('{"title":"根据 token 获取用户信息","description":"","frontmatter":{},"headers":[],"relativePath":"solutions/根据token获取用户信息.md","filePath":"solutions/根据token获取用户信息.md"}'),t={name:"solutions/根据token获取用户信息.md"};function l(h,s,p,k,r,E){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="根据-token-获取用户信息" tabindex="-1">根据 token 获取用户信息 <a class="header-anchor" href="#根据-token-获取用户信息" aria-label="Permalink to &quot;根据 token 获取用户信息&quot;">​</a></h1><h2 id="level1-手动获取" tabindex="-1">Level1: 手动获取 <a class="header-anchor" href="#level1-手动获取" aria-label="Permalink to &quot;Level1: 手动获取&quot;">​</a></h2><p>通常 token 会放在 header 当中，最低级的获取方式就是直接从 header 中获取 token，然后通过 token 转换获得 userId，示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GetMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/level1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">level1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpServletRequest request) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;level1 获得的token为：{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, token);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Integer userId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TokenUtil.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserIdByToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;userId={}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, userId);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userId;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种方式最简单直观，还可以进一步封装，比如提供一个 BaseController，封装公共的部分，本质是一样的，但又引入了继承关系。因此，通常适用于有少数地方使用的场景。如果有大量的地方使用，这样写比较麻烦，** **，也没什么技术含量。</p><h2 id="level2-过滤器-token-转-userid" tabindex="-1">Level2：过滤器 token 转 userId <a class="header-anchor" href="#level2-过滤器-token-转-userid" aria-label="Permalink to &quot;Level2：过滤器 token 转 userId&quot;">​</a></h2><p>在上一种方案中，既然每一次调用都需要进行 token 和 userId 的转换，那就通过过滤器将这一转换过程统一处理。在过滤器中获得 token，然后转换成 userId，再把 userId 写回到 header 当中，使用时直接从 header 中拿 userId 即可。</p><p>先定义过滤器，示例代码如下</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Slf4j</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArgumentFilter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ServletRequest </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ServletResponse </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, FilterChain </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">filterChain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IOException, ServletException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        HttpServletRequest httpRequest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (HttpServletRequest) request;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        HttpServletResponse httpResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (HttpServletResponse) response;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> httpRequest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer userId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TokenUtil.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserIdByToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filter获取用户Id={}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, userId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        HttpServletRequestWrapper requestWrapper </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HttpServletRequestWrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(httpRequest) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;userId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        filterChain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(requestWrapper, httpResponse);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里主要通过实现 Filter 接口的 doFilter 方法（JDK8 可用实现需要的接口方法即可），在 request 中获得 token 之后，通过 HttpServletRequestWrapper 将转换之后的 userId 放置在 header 当中。</p><p>虽然这种方式已经进步了很多，但每次都要获得 HttpServletRequest，然后再从其中获得 userId，还是有一些不方便</p><h2 id="level3-参数匹配" tabindex="-1">Level3：参数匹配 <a class="header-anchor" href="#level3-参数匹配" aria-label="Permalink to &quot;Level3：参数匹配&quot;">​</a></h2><p>上一种方式已经处理获得了 userId，那么能不能做的更彻底一些，只需要在 Controller 方法上出现 userId，就直接给它赋值呢？</p><p>这里从 header 中获取到 token，转换为 userId，然后匹配方法的参数名称，如果是 userId，那么就将转换之后的 userId 赋值给对应的参数。</p><p>至此，是不是就完美了？好像还有一些瑕疵。</p><p>第一个：虽然按照约定定义 userId 参数即可，但容易误伤，比如某些业务有自身的 userId，不小心命名重复了，会有被覆盖的风险。</p><p>第二个：参数的名称只能是 userId，且不能够灵活的定义其他名称。</p><p>第三个：如果想返回更多信息，比如用户（User）的信息，处理就变得更加复杂。而且如果 body 体传递的参数比较复杂，解析成 Map 再封装转换有一定的风险和性能问题。</p><h2 id="level4-方法参数解析器" tabindex="-1">Level4：方法参数解析器 <a class="header-anchor" href="#level4-方法参数解析器" aria-label="Permalink to &quot;Level4：方法参数解析器&quot;">​</a></h2><p>Spring 提供了多种解析器 Resolver，比如常用的统一处理异常的 HandlerExceptionResolver。同时，还提供了用来处理方法参数的解析器 HandlerMethodArgumentResolver。它包含 2 个方法：supportsParameter 和 resolveArgument。其中前者用来判断是否满足某个条件，当满足条件（返回 true）则可进入 resolveArgument 方法进行具体处理操作。</p><p>基于 HandlerExceptionResolver，我们可以分以下部分来进行实现：</p><p>自定义注解@CurrentUser，用于 Controller 方法上的 User 参数； 自定义 LoginUserHandlerMethodArgumentResolver，实现 HandlerMethodArgumentResolver 接口，通过 supportsParameter 检查符合条件的参数，通过 resolveArgument 方法来将 token 转换成 User 对象，并赋值给参数。 注册 HandlerMethodArgumentResolver 到 MVC 当中。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/wo541075754/article/details/111466430" target="_blank" rel="noreferrer">根据 Token 获取用户信息的 N 种姿势，这种最完美！</a></li></ul>`,24)]))}const g=i(t,[["render",l]]);export{o as __pageData,g as default};
