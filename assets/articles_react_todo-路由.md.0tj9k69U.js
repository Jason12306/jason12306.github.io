import{_ as t,c as a,o,a2 as r}from"./chunks/framework.CnKoBJ9A.js";const m=JSON.parse('{"title":"路由 react-router-dom","description":"","frontmatter":{},"headers":[],"relativePath":"articles/react/todo-路由.md","filePath":"articles/react/todo-路由.md"}'),l={name:"articles/react/todo-路由.md"};function i(n,e,d,c,s,u){return o(),a("div",null,e[0]||(e[0]=[r('<h1 id="路由-react-router-dom" tabindex="-1">路由 react-router-dom <a class="header-anchor" href="#路由-react-router-dom" aria-label="Permalink to &quot;路由 react-router-dom&quot;">​</a></h1><ul><li><a href="https://reactrouter.com/en/main" target="_blank" rel="noreferrer">官方文档</a></li></ul><h2 id="错误页" tabindex="-1">错误页 <a class="header-anchor" href="#错误页" aria-label="Permalink to &quot;错误页&quot;">​</a></h2><ul><li>errorElement</li><li>ErrorBoundary</li></ul><h2 id="按需加载" tabindex="-1">按需加载 <a class="header-anchor" href="#按需加载" aria-label="Permalink to &quot;按需加载&quot;">​</a></h2><h2 id="参数传递、获取当前实例与全局实例" tabindex="-1">参数传递、获取当前实例与全局实例 <a class="header-anchor" href="#参数传递、获取当前实例与全局实例" aria-label="Permalink to &quot;参数传递、获取当前实例与全局实例&quot;">​</a></h2><ul><li><code>&lt;Link to={xxx}&gt;xxx&lt;/Link&gt;</code></li><li>路径参数 <code>id/:userId</code></li></ul><h2 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h2><h2 id="嵌套路由-nested-routes" tabindex="-1">嵌套路由(Nested Routes) <a class="header-anchor" href="#嵌套路由-nested-routes" aria-label="Permalink to &quot;嵌套路由(Nested Routes)&quot;">​</a></h2><ul><li><code>&lt;Outlet /&gt;</code> 出口</li></ul><h2 id="加载数据" tabindex="-1">加载数据 <a class="header-anchor" href="#加载数据" aria-label="Permalink to &quot;加载数据&quot;">​</a></h2><ul><li>使用路由<code>loader</code>属性可以在组件内通过<code>useLoaderData</code>获取数据</li></ul><h2 id="jsx-路由" tabindex="-1">JSX 路由 <a class="header-anchor" href="#jsx-路由" aria-label="Permalink to &quot;JSX 路由&quot;">​</a></h2><p>可以使用 createRoutesFromElements 配置路由，JSX 或对象之间没有功能上的区别，这只是一种风格偏好。<a href="https://reactrouter.com/en/main/start/tutorial#jsx-routes" target="_blank" rel="noreferrer">jsx-routes</a></p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><ul><li>使用 <code>&lt;xxx /&gt;</code>与直接使用<code>xxx</code>区别 <blockquote><p>When using RouterProvider, if you do not wish to specify a React element (i.e., <code>element={&lt;MyComponent /&gt;}</code>) you may specify a Component instead (i.e., Component={MyComponent}) and React Router will call createElement for you internally. You should only do this for RouterProvider applications though since using Component inside of <code>&lt;Routes&gt;</code> will de-optimize React&#39;s ability to reuse the created element across renders. 使用 RouterProvider 时，如果您不希望指定 React 元素（即 element={<code>&lt;MyComponent /&gt;</code>}），您可以指定一个 Component（即 Component={MyComponent}），React Router 将在内部为您调用 createElement。不过，您应该只对 RouterProvider 应用程序执行此操作，因为在 <code>&lt;Routes&gt;</code> 中使用 Component 会降低 React 在渲染中重用创建元素的能力。</p></blockquote></li></ul><h2 id="官方示例" tabindex="-1">官方示例 <a class="header-anchor" href="#官方示例" aria-label="Permalink to &quot;官方示例&quot;">​</a></h2><ul><li><a href="https://github.com/remix-run/react-router/tree/dev/examples" target="_blank" rel="noreferrer">examples</a></li></ul><h2 id="ssr" tabindex="-1">SSR <a class="header-anchor" href="#ssr" aria-label="Permalink to &quot;SSR&quot;">​</a></h2><ul><li><a href="https://reactrouter.com/en/main/guides/ssr" target="_blank" rel="noreferrer">服务端渲染</a></li></ul>',20)]))}const p=t(l,[["render",i]]);export{m as __pageData,p as default};
