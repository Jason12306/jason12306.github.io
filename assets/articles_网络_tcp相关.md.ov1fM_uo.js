import{_ as e,c as a,o as l,a2 as i}from"./chunks/framework.CnKoBJ9A.js";const r="/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.7Cl8wpta.jpg",P=JSON.parse('{"title":"tcp 相关","description":"","frontmatter":{},"headers":[],"relativePath":"articles/网络/tcp相关.md","filePath":"articles/网络/tcp相关.md"}'),o={name:"articles/网络/tcp相关.md"};function c(p,t,s,n,h,T){return l(),a("div",null,t[0]||(t[0]=[i('<h1 id="tcp-相关" tabindex="-1">tcp 相关 <a class="header-anchor" href="#tcp-相关" aria-label="Permalink to &quot;tcp 相关&quot;">​</a></h1><h2 id="tcp-三次握手与四次挥手" tabindex="-1">tcp 三次握手与四次挥手 <a class="header-anchor" href="#tcp-三次握手与四次挥手" aria-label="Permalink to &quot;tcp 三次握手与四次挥手&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>三次握手目标是建立可靠的通信信道，通过三次握手能够确认客户端与服务端收发能力是正常的。</p><ul><li>第一次握手。客户端发送 SYN 标志的数据包到服务端，客户端进入 SYN_SEND 状态。此时，服务端能确认客户端发送正常，自己接收正常</li><li>第二次握手。服务端发送 SYN+ACK 标志的数据包到客户端，服务端进入 SYN_RECV 状态。此时，客户端能确认自己收发都正常，服务端收发正常。</li><li>第三次握手。客户端发送带有 ACK 标志的数据包到服务端，然后客户端与服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。服务端能确认自己收发正常，客户端收发正常</li></ul><div class="tip custom-block"><p class="custom-block-title">SYN</p><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。</p></div><div class="tip custom-block"><p class="custom-block-title">ACK</p><p>ACK（Acknowledgement）消息响应</p></div><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><ul><li>第一次挥手。客户端发送 FIN 标志的数据包到服务端，关闭客户端到服务端的数据传送，客户端进入 FIN-WAIT-1 状态</li><li>第二次挥手。服务端收到带有 FIN 标志数据包后，向客户端发送带有 ACK 标志的数据包，服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态</li><li>第三次挥手。服务端数据传输完成后，向客户端发送 FIN 标志的数据包，请求关闭连接，服务端进入 LAST-ACK 状态</li><li>第四次挥手。客户端向服务端发送 ACK 数据包，客户端进入 TIME-WAIT 状态，服务端接收到 ACK 的数据包后进入 CLOSE 状态，客户端等待 2MSL 后，没收到服务端的回复，则知道服务端已关闭，客户端关闭连接。</li></ul><p>为什么要四次挥手？ TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举例说明</p><ol><li>第一次挥手：A 说“我没啥要说的了”</li><li>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li>第四次挥手：A 回答“知道了”，这样通话才算结束。</li></ol><div class="tip custom-block"><p class="custom-block-title">MSL</p><p>MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></div><p><a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html" target="_blank" rel="noreferrer">参考资料</a></p><h2 id="http-2-关键特性" tabindex="-1">http/2 关键特性 <a class="header-anchor" href="#http-2-关键特性" aria-label="Permalink to &quot;http/2 关键特性&quot;">​</a></h2><ul><li>二进制分帧：在 HTTP 的报文传输格式方面，HTTP/1.1 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码</li><li>头部压缩：HTTP 每次请求或响应都会携带首部信息用于描述资源属性。HTTP/1.1 使用文本的形式传输消息头，消息头中携带 cookie 每次都需要重复传输几百到几千的字节，这十分占用资源。HTTP/2 使用了 HPACK 算法来压缩头字段，这种压缩格式对传输的头字段进行编码，减少了头字段的大小。同时，在两端维护了索引表，用于记录出现过的头字段，后面在传输过程中就可以传输已经记录过的头字段的索引号，对端收到数据后就可以通过索引号找到对应的值。</li><li>多路复用：HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，实现多流并行而并不依赖多个 TCP 连接，并行地在同一个 TCP 连接上双向交换消息，HTTP/2 基于二进制分帧层，在另一端根据流标识符和首部将他们重新组装起来</li><li>服务端推送：在 HTTP/2 中，服务器可以对一个客户端的请求发送多个响应。如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo 以及样式表，因为服务端知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。</li></ul><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/HTTP--2.html" target="_blank" rel="noreferrer">参考文档</a></p><h2 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-label="Permalink to &quot;网络协议&quot;">​</a></h2><p>TCP/IP 即传输控制协议/网络互联协议，是针对 Internet 开发的一种体系结构和协议标准，相对于 OSI 体系结构更简洁。分层体系，由下至上分别是网络接口层、网际层、传输层和应用层（四层分法）。</p><p>TCP/IP 则是四层的结构，相当于是对 OSI（Open System Interconnect 的缩写，意为开放式系统互联）模型的简化</p><p>应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p><img src="'+r+'"><ul><li><p>数据链路层，也有称作网络访问层、网络接口层。他包含了 OSI 模型的物理层和数据链路层，把电脑连接起来。</p></li><li><p>网络层，也叫做 IP 层，处理 IP 数据包的传输、路由，建立主机间的通信。</p></li><li><p>传输层，传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信。</p></li><li><p>应用层，包含 OSI 的会话层、表示层和应用层，提供了一些常用的协议规范，比如 FTP、SMPT、HTTP 等。</p></li><li><p><a href="https://cloud.tencent.com/developer/article/2183899" target="_blank" rel="noreferrer">参考资料</a></p></li></ul><h2 id="http-与-websocket" tabindex="-1">http 与 websocket <a class="header-anchor" href="#http-与-websocket" aria-label="Permalink to &quot;http 与 websocket&quot;">​</a></h2><ul><li><a href="https://apifox.com/apiskills/websocket-vs-http/" target="_blank" rel="noreferrer">WebSocket 和 HTTP 的区别深解</a></li></ul>',25)]))}const u=e(o,[["render",c]]);export{P as __pageData,u as default};
