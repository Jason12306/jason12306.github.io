import{_ as o,c as d,o as r,a2 as s}from"./chunks/framework.CnKoBJ9A.js";const e="/assets/test-demo.CIVv9GB-.png",m=JSON.parse('{"title":"关于测试","description":"","frontmatter":{},"headers":[],"relativePath":"articles/前端/关于测试.md","filePath":"articles/前端/关于测试.md"}'),n={name:"articles/前端/关于测试.md"};function a(l,t,g,i,h,c){return r(),d("div",null,t[0]||(t[0]=[s('<h1 id="关于测试" tabindex="-1">关于测试 <a class="header-anchor" href="#关于测试" aria-label="Permalink to &quot;关于测试&quot;">​</a></h1><img src="'+e+'" alt="图片demo"><p>这份报告是 Vitest 测试运行器结合 Istanbul 生成的代码覆盖率报告。以下是各部分的详细解释：</p><hr><h3 id="顶部摘要-summary" tabindex="-1"><strong>顶部摘要 (Summary)</strong> <a class="header-anchor" href="#顶部摘要-summary" aria-label="Permalink to &quot;**顶部摘要 (Summary)**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指标</th><th>说明</th><th>当前值</th></tr></thead><tbody><tr><td><strong>Statements</strong></td><td>可执行语句覆盖率</td><td>6.61% (89/1210)</td></tr><tr><td><strong>Branches</strong></td><td>条件分支覆盖率（如 <code>if/else</code>）</td><td>66.66% (24/26)</td></tr><tr><td><strong>Functions</strong></td><td>函数/方法调用覆盖率</td><td>50% (13/24)</td></tr><tr><td><strong>Lines</strong></td><td>代码行覆盖率</td><td>6.61% (169/1210)</td></tr></tbody></table><hr><h3 id="测试状态概览" tabindex="-1"><strong>测试状态概览</strong> <a class="header-anchor" href="#测试状态概览" aria-label="Permalink to &quot;**测试状态概览**&quot;">​</a></h3><ul><li><strong>FALL (0)</strong>：失败测试数（0 表示全部通过）</li><li><strong>RUNNING (0)</strong>：运行中测试数（0 表示无测试进行中）</li><li><strong>PASS (1)</strong>：通过测试数（1 个测试通过）</li><li><strong>SKIP (--)</strong>：跳过测试数（<code>--</code> 表示未统计或无数值）</li></ul><hr><p>在代码覆盖率报告（如Istanbul/nyc生成的报告）中，<strong>1x</strong> 表示该行代码在测试过程中<strong>被成功执行了1次</strong>。这是覆盖率工具对代码执行频率的可视化标记系统，具体含义如下：</p><h3 id="不同标记的含义" tabindex="-1">不同标记的含义 <a class="header-anchor" href="#不同标记的含义" aria-label="Permalink to &quot;不同标记的含义&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th><th>视觉表现</th></tr></thead><tbody><tr><td><strong>1x</strong></td><td>代码被执行了1次</td><td>通常显示为<span style="color:green;">绿色背景</span></td></tr><tr><td><strong>2x</strong>, <strong>3x</strong></td><td>代码被执行了多次</td><td>数字越大颜色越深绿</td></tr><tr><td><strong>0x</strong></td><td>代码从未被执行</td><td>显示为<span style="color:red;">红色背景</span></td></tr><tr><td><strong>I</strong></td><td>忽略的代码（如注释）</td><td>灰色或无背景色</td></tr><tr><td><strong>E</strong></td><td>执行出错的代码</td><td>黄色或橙色背景</td></tr></tbody></table><h3 id="为什么关注-1x" tabindex="-1">为什么关注&quot;1x&quot; <a class="header-anchor" href="#为什么关注-1x" aria-label="Permalink to &quot;为什么关注&quot;1x&quot;&quot;">​</a></h3><ol><li><strong>最低通过标准</strong>：1x表示代码至少被测试覆盖一次</li><li><strong>质量指标</strong>： <ul><li>关键代码应有更高执行次数（如3x+）</li><li>1x可能暗示边缘case覆盖不足</li></ul></li><li><strong>风险识别</strong>： <ul><li>所有1x代码需验证是否包含分支逻辑</li><li>高频方法(3x+)应检查性能影响</li></ul></li></ol><blockquote><p>💡 <strong>最佳实践</strong>：核心业务逻辑的目标执行次数应≥3x，而工具类方法保持1x即可接受。</p></blockquote><h2 id="jsdom-和-happy-dom" tabindex="-1">jsdom 和 happy-dom <a class="header-anchor" href="#jsdom-和-happy-dom" aria-label="Permalink to &quot;jsdom 和 happy-dom&quot;">​</a></h2><p><code>jsdom</code> 和 <code>happy-dom</code> 都是用于在 Node.js 环境中模拟浏览器 DOM 的 JavaScript 库，但它们的设计目标、性能表现和功能支持有所不同。以下是两者的核心区别：</p><hr><h3 id="_1-设计目标与主要用途" tabindex="-1"><strong>1. 设计目标与主要用途</strong> <a class="header-anchor" href="#_1-设计目标与主要用途" aria-label="Permalink to &quot;**1. 设计目标与主要用途**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>jsdom</strong></th><th><strong>happy-dom</strong></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>通用 DOM 模拟，兼容传统 Web 标准</td><td>专注于 Web Components 和 SSR（服务器端渲染）</td></tr><tr><td><strong>性能优化</strong></td><td>较慢（尤其在 23.2.0 版本后性能下降）</td><td>更快，专为高效 DOM 操作优化</td></tr><tr><td><strong>适用场景</strong></td><td>测试、爬虫、传统 DOM 操作</td><td>现代前端框架（如 Lit、Stencil）、SSR、测试</td></tr></tbody></table><p><strong>关键差异</strong>：</p><ul><li><code>jsdom</code> 更通用，但性能较差，尤其是在复杂选择器操作时。</li><li><code>happy-dom</code> 针对 Web Components 和 SSR 优化，执行速度更快。</li></ul><hr><h3 id="_2-性能对比" tabindex="-1"><strong>2. 性能对比</strong> <a class="header-anchor" href="#_2-性能对比" aria-label="Permalink to &quot;**2. 性能对比**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>操作</strong></th><th><strong>jsdom</strong> (ms)</th><th><strong>happy-dom</strong> (ms)</th></tr></thead><tbody><tr><td><strong>HTML 解析</strong></td><td>256</td><td>26</td></tr><tr><td><strong>序列化 HTML</strong></td><td>65</td><td>8</td></tr><tr><td><strong>渲染自定义元素</strong></td><td>214</td><td>19</td></tr><tr><td><strong><code>querySelectorAll</code></strong></td><td>4.9–10.4</td><td>0.7–3.8</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li><code>happy-dom</code> 在 DOM 操作和解析方面比 <code>jsdom</code> 快 <strong>5–10 倍</strong>。</li><li><code>jsdom</code> 23.2.0 版本因更换选择器引擎导致性能显著下降（如 <code>querySelector</code> 慢 800 倍）。</li></ul><hr><h3 id="_3-功能支持" tabindex="-1"><strong>3. 功能支持</strong> <a class="header-anchor" href="#_3-功能支持" aria-label="Permalink to &quot;**3. 功能支持**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>功能</strong></th><th><strong>jsdom</strong></th><th><strong>happy-dom</strong></th></tr></thead><tbody><tr><td><strong>Shadow DOM</strong></td><td>✅</td><td>✅（更优支持）</td></tr><tr><td><strong>MutationObserver</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>Fetch API</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>CSSOM 支持</strong></td><td>✅</td><td>✅（部分优化）</td></tr><tr><td><strong><code>&lt;details&gt;</code> 元素</strong></td><td>✅（标准）</td><td>✅（旧版有差异，已修复）</td></tr><tr><td><strong>文件加载控制</strong></td><td>❌（默认加载）</td><td>✅（可禁用 JS/CSS 加载）</td></tr></tbody></table><p><strong>关键差异</strong>：</p><ul><li><code>happy-dom</code> 允许禁用文件加载（<code>disableJavaScriptFileLoading</code>），适合单元测试。</li><li><code>jsdom</code> 对传统 Web API 支持更完整，但 <code>happy-dom</code> 更适合现代 Web Components 开发。</li></ul><hr><h3 id="_4-兼容性与-seo-优化" tabindex="-1"><strong>4. 兼容性与 SEO 优化</strong> <a class="header-anchor" href="#_4-兼容性与-seo-优化" aria-label="Permalink to &quot;**4. 兼容性与 SEO 优化**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>方面</strong></th><th><strong>jsdom</strong></th><th><strong>happy-dom</strong></th></tr></thead><tbody><tr><td><strong>SSR 优化</strong></td><td>❌</td><td>✅（专为 SSR 设计）</td></tr><tr><td><strong>SEO 友好</strong></td><td>❌</td><td>✅（预渲染支持更好）</td></tr><tr><td><strong>TypeScript 支持</strong></td><td>✅</td><td>✅（v18+ 类型更严格）</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li>如果项目需要 <strong>服务器端渲染（SSR）</strong> 或 <strong>SEO 优化</strong>，<code>happy-dom</code> 是更好的选择。</li><li><code>jsdom</code> 适合需要 <strong>完整浏览器模拟</strong> 但不太关注性能的场景。</li></ul><hr><h3 id="_5-临时解决方案与版本问题" tabindex="-1"><strong>5. 临时解决方案与版本问题</strong> <a class="header-anchor" href="#_5-临时解决方案与版本问题" aria-label="Permalink to &quot;**5. 临时解决方案与版本问题**&quot;">​</a></h3><ul><li><strong><code>jsdom</code> 性能问题</strong>： <ul><li>23.2.0 版本因选择器引擎变更导致性能下降，可回退到 23.1.0 或使用优化版 <code>dom-selector</code>。</li></ul></li><li><strong><code>happy-dom</code> 行为差异</strong>： <ul><li>旧版对 <code>&lt;details&gt;</code> 元素的 <code>open</code> 属性处理与浏览器不一致，但最新版本已修复。</li></ul></li></ul><hr><h3 id="总结-如何选择" tabindex="-1"><strong>总结：如何选择？</strong> <a class="header-anchor" href="#总结-如何选择" aria-label="Permalink to &quot;**总结：如何选择？**&quot;">​</a></h3><ul><li><strong>选 <code>happy-dom</code> 如果</strong>： <ul><li>需要 <strong>高性能 DOM 操作</strong>（如测试、SSR）。</li><li>项目基于 <strong>Web Components</strong> 或需要 <strong>Shadow DOM</strong> 支持。</li><li>希望 <strong>禁用文件加载</strong> 以加速单元测试。</li></ul></li><li><strong>选 <code>jsdom</code> 如果</strong>： <ul><li>需要 <strong>最接近真实浏览器的行为</strong>（如爬虫、复杂 DOM 测试）。</li><li>依赖 <strong>旧版 Web API</strong> 或无法升级到 <code>happy-dom</code>。</li></ul></li></ul><blockquote><p><strong>最新趋势</strong>：越来越多的现代框架（如 Vitest）开始默认使用 <code>happy-dom</code> 替代 <code>jsdom</code>，因其更快的速度和更低的资源占用。</p></blockquote>',45)]))}const u=o(n,[["render",a]]);export{m as __pageData,u as default};
