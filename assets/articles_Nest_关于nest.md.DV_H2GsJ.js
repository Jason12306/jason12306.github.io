import{_ as s,c as t,o as a,a2 as i}from"./chunks/framework.CnKoBJ9A.js";const n="/assets/exception-filter_min.Beb3eWCy.png",r="/assets/pipe.CGQZeaNx.png",u=JSON.parse('{"title":"关于 nest","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Nest/关于nest.md","filePath":"articles/Nest/关于nest.md"}'),p={name:"articles/Nest/关于nest.md"};function l(o,e,c,h,d,k){return a(),t("div",null,e[0]||(e[0]=[i('<h1 id="关于-nest" tabindex="-1">关于 nest <a class="header-anchor" href="#关于-nest" aria-label="Permalink to &quot;关于 nest&quot;">​</a></h1><h2 id="vscode-调试-nest" tabindex="-1">vscode 调试 nest <a class="header-anchor" href="#vscode-调试-nest" aria-label="Permalink to &quot;vscode 调试 nest&quot;">​</a></h2><p>常规<code>launch.json</code>配置，<code>npm</code>启动<code>start:debug</code>命令</p><h2 id="异常过滤器" tabindex="-1"><a href="https://docs.nestjs.com/exception-filters" target="_blank" rel="noreferrer">异常过滤器</a> <a class="header-anchor" href="#异常过滤器" aria-label="Permalink to &quot;[异常过滤器](https://docs.nestjs.com/exception-filters)&quot;">​</a></h2><p>Nest 带有一个内置的异常层，该层负责<strong>处理应用程序中所有未处理的异常</strong>。当应用程序代码未处理异常时，<strong>该层会捕获该异常</strong>，然后该层会自动发送适当的用户友好响应。</p><p><img src="'+n+`" alt="alt text"></p><p>此操作由内置的全局异常筛选器执行，该筛选器处理 HttpException 类型的异常（及其子类）。当无法识别异常时（既不是 HttpException 也不是继承自 HttpException 的类），内置的异常过滤器会生成以下默认 JSON 响应：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;statusCode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Internal server error&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="管道-pipe" tabindex="-1"><a href="https://docs.nestjs.com/pipes" target="_blank" rel="noreferrer">管道（pipe）</a> <a class="header-anchor" href="#管道-pipe" aria-label="Permalink to &quot;[管道（pipe）](https://docs.nestjs.com/pipes)&quot;">​</a></h2><p>管道是一个用 <code>@Injectable()</code> 装饰器注释的类，它实现了 <code>PipeTransform</code> 接口。</p><p><img src="`+r+'" alt="pipe"></p><p>管道有两个典型的用例：</p><ul><li>转换：将输入数据转换为所需的形式（例如，从 String 到 Integer）</li><li>验证：评估输入数据，如果有效，只需将其原封不动地传递即可;否则，抛出异常</li></ul><p>在这两种情况下，管道都对<strong>控制器路由处理程序</strong>正在处理的<strong>参数</strong>进行操作。Nest 在调用方法之前插入一个管道，管道接收发往该方法的参数并对其执行操作。任何转换或验证操作都发生在这个时候，之后将使用任何（可能）转换的参数调用路由处理程序。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>管道在异常区域内运行。这意味着，当 Pipe 引发异常时，它由异常层（全局异常过滤器和应用于当前上下文的任何异常过滤器）处理。鉴于上述情况，应该很清楚，当在 Pipe 中抛出异常时，随后不会执行任何控制器方法。这为您提供了一种最佳实践技术，用于验证从系统边界的外部源进入应用程序的数据。</p></div><h2 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-label="Permalink to &quot;微服务&quot;">​</a></h2><ul><li><p><a href="https://juejin.cn/post/7207637337571901495" target="_blank" rel="noreferrer">Nest.js 的微服务，写起来也太简单了吧！</a></p></li><li><p><a href="https://juejin.cn/post/7264922511883780108" target="_blank" rel="noreferrer">Nestjs 结合 Nacos 实现配置中心和注册中心</a></p></li><li><p><a href="https://wanago.io/" target="_blank" rel="noreferrer">nestjs 学习网站</a></p></li><li><p><a href="https://blog.csdn.net/qq_54247497/article/details/131498213" target="_blank" rel="noreferrer">SpringCloud 篇：GateWay 网关</a></p></li><li><p><a href="https://www.cnblogs.com/Yee-Q/p/17673998.html" target="_blank" rel="noreferrer">SpringCloud 微服务网关</a></p></li></ul>',17)]))}const _=s(p,[["render",l]]);export{u as __pageData,_ as default};
