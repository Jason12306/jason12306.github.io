import{_ as i,c as a,o as e,a2 as t}from"./chunks/framework.CnKoBJ9A.js";const c=JSON.parse('{"title":"nest 中的时序","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Nest/nest中的时序.md","filePath":"articles/Nest/nest中的时序.md"}'),n={name:"articles/Nest/nest中的时序.md"};function l(p,s,h,r,k,d){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="nest-中的时序" tabindex="-1">nest 中的时序 <a class="header-anchor" href="#nest-中的时序" aria-label="Permalink to &quot;nest 中的时序&quot;">​</a></h1><blockquote><p>middleware INPUT -&gt; guard -&gt; middleware OUTPUT -&gt; interceptor INPUT -&gt; pipe -&gt; controller -&gt; interceptor OUTPUT</p></blockquote><h2 id="middleware-中间件" tabindex="-1">Middleware（中间件） <a class="header-anchor" href="#middleware-中间件" aria-label="Permalink to &quot;Middleware（中间件）&quot;">​</a></h2><p>Middleware 是在路由处理程序之前调用的函数。中间件函数可以访问请求和响应对象，以及应用程序的请求-响应周期中的 next() 中间件函数。next 中间件函数通常由名为 next 的变量表示。默认情况下，Nest 中间件等同于 express 中间件。</p><ul><li><a href="https://docs.nestjs.com/middleware" target="_blank" rel="noreferrer">Middleware</a></li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Injectable, NestMiddleware } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Request, Response, NextFunction } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;express&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Injectable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LoggerMiddleware</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NestMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NextFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Request...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="pipes-管道" tabindex="-1">Pipes 管道 <a class="header-anchor" href="#pipes-管道" aria-label="Permalink to &quot;Pipes 管道&quot;">​</a></h2><p>管道是一个用 @Injectable() 装饰器注释的类，它实现了 PipeTransform 接口。</p><p>管道有两个典型的用例：</p><ul><li>transformation：将输入数据转换为所需的形式（例如，从 String 到 Integer）</li><li>validation：评估输入数据，如果有效，只需将其原封不动地传递即可；否则，抛出异常</li></ul><p>在这两种情况下，管道都对控制器路由处理程序正在处理的参数进行操作。<strong>Nest 在调用方法之前插入一个管道，管道接收发往该方法的参数并对其执行操作</strong>。任何转换或验证操作都发生在该时间，之后将使用任何（可能）转换的参数调用路由处理程序。</p><h2 id="guards-警卫" tabindex="-1">Guards 警卫 <a class="header-anchor" href="#guards-警卫" aria-label="Permalink to &quot;Guards 警卫&quot;">​</a></h2><p>守卫是一个用 @Injectable（） 装饰器注释的类，它实现了 CanActivate 接口。</p><p>警卫只有一项职责。它们根据运行时存在的某些条件（如权限、角色、ACL 等）确定给定请求是否由路由处理程序处理。这通常称为授权。授权（及其表亲 authentication，它通常与之协作）通常由传统 Express 应用程序中的中间件处理。中间件是身份验证的不错选择，因为令牌验证和将属性附加到请求对象之类的事情与特定的路由上下文（及其元数据）没有紧密联系。</p><blockquote><p>守卫在所有 middleware 之后执行，但在任何拦截器或管道之前执行。</p></blockquote><p>守卫引发的任何异常都将由异常层（全局异常过滤器和应用于当前上下文的任何异常过滤器）处理。</p><h2 id="interceptors-拦截器" tabindex="-1">Interceptors 拦截器 <a class="header-anchor" href="#interceptors-拦截器" aria-label="Permalink to &quot;Interceptors 拦截器&quot;">​</a></h2><p>拦截器是一个用 @Injectable（） 装饰器注释的类，并实现 NestInterceptor 接口。</p><h2 id="exception-filters-异常过滤器" tabindex="-1">Exception filters（异常过滤器） <a class="header-anchor" href="#exception-filters-异常过滤器" aria-label="Permalink to &quot;Exception filters（异常过滤器）&quot;">​</a></h2><p>Nest 带有一个内置的异常层，该层负责处理应用程序中所有未处理的异常。当应用程序代码未处理异常时，该层会捕获该异常，然后该层会自动发送适当的用户友好响应。</p>`,20)]))}const E=i(n,[["render",l]]);export{c as __pageData,E as default};
